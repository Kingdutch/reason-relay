// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Snapshot tests for useAnyDirectory matches expected output: refetchable-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment RefetchableFragment on Node
  @refetchable(queryName: "RefetchableFragmentQuery") {
  id
  fragAndField: profilePicture {
    uri
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// RefetchableFragment.graphql



// RefetchableFragmentQuery.graphql
type response = {. "node": Js.Nullable.t(unit)};
type variables = {. "id": string};

`;

exports[`Snapshot tests for useHaste matches expected output: conditional.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment ConditionField on Node {
  id @include(if: $condition)
}

fragment NestedCondition on Node {
  ... @include(if: $condition) {
    id
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// ConditionField.graphql



// NestedCondition.graphql


`;

exports[`Snapshot tests for useHaste matches expected output: fragment-spread.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment FragmentSpread on Node {
  id
  ...OtherFragment
  justFrag: profilePicture {
    ...PictureFragment
  }
  fragAndField: profilePicture {
    uri
    ...PictureFragment
  }
  ... on User {
    ...UserFrag1
    ...UserFrag2
  }
}

fragment ConcreateTypes on Viewer {
  actor {
    __typename
    ... on Page {
      id
      ...PageFragment
    }
    ... on User {
      name
    }
  }
}

fragment PictureFragment on Image {
  __typename
}

fragment OtherFragment on Node {
  __typename
}

fragment PageFragment on Page {
  __typename
}

fragment UserFrag1 on Page {
  __typename
}

fragment UserFrag2 on Page {
  __typename
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// FragmentSpread.graphql



// ConcreateTypes.graphql



// PictureFragment.graphql



// OtherFragment.graphql



// PageFragment.graphql



// UserFrag1.graphql



// UserFrag2.graphql


`;

exports[`Snapshot tests for useHaste matches expected output: inline-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment InlineFragment on Node {
  id
  ... on Actor {
    id
    name
  }
  ... on User {
    message {
      text
    }
  }
}

fragment InlineFragmentWithOverlappingFields on Actor {
  ... on User {
    hometown {
      id
      name
    }
  }
  ... on Page {
    name
    hometown {
      id
      message {
        text
      }
    }
  }
}

fragment InlineFragmentConditionalID on Node {
  ... on Actor {
    id # nullable since it's conditional
    name
  }
}

fragment InlineFragmentKitchenSink on Story {
  actor {
    id
    profilePicture {
      uri
    }
    ... on User {
      id
      name
      ...SomeFragment
      profilePicture {
        width
      }
    }
    ... on Page {
      profilePicture {
        uri
        height
      }
    }
  }
}

fragment SomeFragment on User {
  __typename
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// InlineFragment.graphql



// InlineFragmentWithOverlappingFields.graphql



// InlineFragmentConditionalID.graphql



// InlineFragmentKitchenSink.graphql



// SomeFragment.graphql


`;

exports[`Snapshot tests for useHaste matches expected output: linked-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment LinkedField on User {
  profilePicture {
    uri
    width
    height
  }
  hometown {
    # object
    id
    profilePicture {
      uri
    }
  }
  actor {
    # interface
    id
  }
}

query UnionTypeTest {
  neverNode {
    __typename
    ... on FakeNode {
      id
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// LinkedField.graphql



// UnionTypeTest.graphql
type union_response_neverNode_wrapped;

module Union_response_neverNode: {
  type type_FakeNode = {. "id": string};
  type t = [ | \`FakeNode(type_FakeNode) | \`UnmappedUnionMember];
  let unwrap: union_response_neverNode_wrapped => t;
} = {
  external __unwrap_union:
    union_response_neverNode_wrapped => {. "__typename": string} =
    "%identity";
  type type_FakeNode = {. "id": string};
  type t = [ | \`FakeNode(type_FakeNode) | \`UnmappedUnionMember];
  external __unwrap_FakeNode: union_response_neverNode_wrapped => type_FakeNode =
    "%identity";
  let unwrap = wrapped => {
    let unwrappedUnion = wrapped |> __unwrap_union;
    switch (unwrappedUnion##__typename) {
    | "FakeNode" => \`FakeNode(wrapped |> __unwrap_FakeNode)
    | _ => \`UnmappedUnionMember
    };
  };
};
type response = {. "neverNode": union_response_neverNode_wrapped};
type variables = unit;

`;

exports[`Snapshot tests for useHaste matches expected output: match-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment NameRendererFragment on User {
  id
  nameRenderer @match {
    ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
    ...MarkdownUserNameRenderer_name
      @module(name: "MarkdownUserNameRenderer.react")
  }
}

fragment PlainUserNameRenderer_name on PlainUserNameRenderer {
  plaintext
  data {
    text
  }
}

fragment MarkdownUserNameRenderer_name on MarkdownUserNameRenderer {
  markdown
  data {
    markup
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// NameRendererFragment.graphql



// PlainUserNameRenderer_name.graphql



// MarkdownUserNameRenderer_name.graphql


`;

exports[`Snapshot tests for useHaste matches expected output: match-field-in-query.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query NameRendererQuery {
  me {
    nameRenderer @match {
      ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
      ...MarkdownUserNameRenderer_name
        @module(name: "MarkdownUserNameRenderer.react")
    }
  }
}

fragment PlainUserNameRenderer_name on PlainUserNameRenderer {
  plaintext
  data {
    text
  }
}

fragment MarkdownUserNameRenderer_name on MarkdownUserNameRenderer {
  markdown
  data {
    markup
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// NameRendererQuery.graphql
type response = {
  .
  "me":
    Js.Nullable.t({
      .
      "nameRenderer":
        Js.Nullable.t({
          .
          "__$fragment_ref__MarkdownUserNameRenderer_name": MarkdownUserNameRenderer_name_graphql.t,
          "__$fragment_ref__PlainUserNameRenderer_name": PlainUserNameRenderer_name_graphql.t,
          "__module_component": Js.Nullable.t(string),
          "__fragmentPropName": Js.Nullable.t(string),
        }),
    }),
};
type variables = unit;


// PlainUserNameRenderer_name.graphql



// MarkdownUserNameRenderer_name.graphql


`;

exports[`Snapshot tests for useHaste matches expected output: mutaion-with-client-extension.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation Test($input: UpdateAllSeenStateInput) @raw_response_type {
  viewerNotificationsUpdateAllSeenState(input: $input) {
    stories {
      foos {
        bar
      }
    }
  }
}

extend type Story {
  foos: [Foo]
}

type Foo {
  bar: String
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// Test.graphql
type response = {
  .
  "viewerNotificationsUpdateAllSeenState":
    Js.Nullable.t({. "stories": ReasonRelay.any}),
};
type variables = {. "input": option(ReasonRelay.any)};

`;

exports[`Snapshot tests for useHaste matches expected output: mutation-input-has-array.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation InputHasArray($input: UpdateAllSeenStateInput) @raw_response_type {
  viewerNotificationsUpdateAllSeenState(input: $input) {
    stories {
      actorCount
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// InputHasArray.graphql
type response = {
  .
  "viewerNotificationsUpdateAllSeenState":
    Js.Nullable.t({. "stories": ReasonRelay.any}),
};
type variables = {. "input": option(ReasonRelay.any)};

`;

exports[`Snapshot tests for useHaste matches expected output: plural-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment PluralFragment on Node @relay(plural: true) {
  id
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// PluralFragment.graphql


`;

exports[`Snapshot tests for useHaste matches expected output: query-with-defer.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query TestDefer @raw_response_type {
  node(id: "1") {
    ... on User {
      name
      friends(first: 10) {
        edges {
          ... on FriendsConnection @defer {
            pageInfo {
              endCursor
              hasNextPage
            }
          }
        }
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// TestDefer.graphql
type response = {
  .
  "node":
    Js.Nullable.t({
      .
      "friends": Js.Nullable.t({. "edges": ReasonRelay.any}),
      "name": Js.Nullable.t(string),
    }),
};
type variables = unit;

`;

exports[`Snapshot tests for useHaste matches expected output: query-with-handles.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query LinkedHandleField($id: ID!) @raw_response_type {
  node(id: $id) {
    ... on User {
      friends(first: 10) @__clientField(handle: "clientFriends") {
        count
      }
    }
  }
}

query ScalarHandleField($id: ID!) @raw_response_type {
  node(id: $id) {
    ... on User {
      name @__clientField(handle: "clientName")
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// LinkedHandleField.graphql
type response = {
  .
  "node":
    Js.Nullable.t({
      .
      "friends": Js.Nullable.t({. "count": Js.Nullable.t(int)}),
    }),
};
type variables = {. "id": string};


// ScalarHandleField.graphql
type response = {
  .
  "node": Js.Nullable.t({. "name": Js.Nullable.t(string)}),
};
type variables = {. "id": string};

`;

exports[`Snapshot tests for useHaste matches expected output: query-with-match-fields.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query Test @raw_response_type {
  node(id: "1") {
    ...NameRendererFragment
  }
}

fragment NameRendererFragment on User {
  id
  nameRenderer @match {
    ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
    ...MarkdownUserNameRenderer_name
      @module(name: "MarkdownUserNameRenderer.react")
  }
}

fragment PlainUserNameRenderer_name on PlainUserNameRenderer {
  plaintext
  data {
    text
  }
}

fragment MarkdownUserNameRenderer_name on MarkdownUserNameRenderer {
  markdown
  data {
    markup
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// Test.graphql
type response = {. "node": Js.Nullable.t(unit)};
type variables = unit;


// NameRendererFragment.graphql



// PlainUserNameRenderer_name.graphql



// MarkdownUserNameRenderer_name.graphql


`;

exports[`Snapshot tests for useHaste matches expected output: query-with-multiple-match-fields.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query Test @raw_response_type {
  node(id: "1") {
    ... on User {
      username
      ...NameRendererFragment
    }
  }
  viewer {
    ... on User {
      name
      ...AnotherNameRendererFragment
    }
  }
}

fragment NameRendererFragment on User {
  id
  nameRenderer @match {
    ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
    ...MarkdownUserNameRenderer_name
      @module(name: "MarkdownUserNameRenderer.react")
  }
}

fragment AnotherNameRendererFragment on User {
  name
  nameRenderer @match {
    ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
    ...MarkdownUserNameRenderer_name
      @module(name: "MarkdownUserNameRenderer.react")
  }
}

fragment PlainUserNameRenderer_name on PlainUserNameRenderer {
  plaintext
  data {
    text
  }
}

fragment MarkdownUserNameRenderer_name on MarkdownUserNameRenderer {
  markdown
  data {
    markup
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// Test.graphql
type response = {
  .
  "viewer": Js.Nullable.t({. "name": Js.Nullable.t(string)}),
  "node": Js.Nullable.t({. "username": Js.Nullable.t(string)}),
};
type variables = unit;


// NameRendererFragment.graphql



// AnotherNameRendererFragment.graphql



// PlainUserNameRenderer_name.graphql



// MarkdownUserNameRenderer_name.graphql


`;

exports[`Snapshot tests for useHaste matches expected output: query-with-raw-response-on-conditional.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query ExampleQuery($id: ID!, $condition: Boolean!) @raw_response_type {
  node(id: $id) {
    ...FriendFragment
  }
}

fragment FriendFragment on User {
  ... @include(if: $condition) {
    name
    lastName
    feedback {
      id
      name
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// ExampleQuery.graphql
type response = {. "node": Js.Nullable.t(unit)};
type variables = {
  .
  "condition": bool,
  "id": string,
};


// FriendFragment.graphql


`;

exports[`Snapshot tests for useHaste matches expected output: query-with-stream.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query TestStream @raw_response_type {
  node(id: "1") {
    ... on User {
      name
      friends(first: 10)
        @stream_connection(
          key: "PaginationFragment_friends"
          initial_count: 1
        ) {
        edges {
          node {
            id
          }
        }
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// TestStream.graphql
type response = {
  .
  "node":
    Js.Nullable.t({
      .
      "friends": Js.Nullable.t({. "edges": ReasonRelay.any}),
      "name": Js.Nullable.t(string),
    }),
};
type variables = unit;

`;

exports[`Snapshot tests for useHaste matches expected output: recursive-fragments.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment FragmentSpread on Node {
  id
  ... @include(if: $condition) {
    ...FragmentSpread
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// FragmentSpread.graphql


`;

exports[`Snapshot tests for useHaste matches expected output: refetchable-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment RefetchableFragment on Node
  @refetchable(queryName: "RefetchableFragmentQuery") {
  id
  fragAndField: profilePicture {
    uri
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// RefetchableFragment.graphql



// RefetchableFragmentQuery.graphql
type response = {. "node": Js.Nullable.t(unit)};
type variables = {. "id": string};

`;

exports[`Snapshot tests for useHaste matches expected output: scalar-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment ScalarField on User {
  id
  name
  websites
  traits
  aliasedLinkedField: birthdate {
    aliasedField: year
  }
  screennames {
    name
    service
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// ScalarField.graphql


`;

exports[`Snapshot tests for useHaste matches expected output: typename-inside-with-overlapping-fields.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment TypenameInsideWithOverlappingFields on Viewer {
  actor {
    __typename
    ... on Page {
      id
      name
    }
    ... on User {
      id
      name
      profile_picture {
        uri
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// TypenameInsideWithOverlappingFields.graphql


`;

exports[`Snapshot tests for useHaste matches expected output: typename-on-union.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment TypenameInside on Actor {
  ... on User {
    __typename
    firstName
  }
  ... on Page {
    __typename
    username
  }
}

fragment TypenameOutside on Actor {
  __typename
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

fragment TypenameOutsideWithAbstractType on Node {
  __typename
  ... on User {
    firstName
    address {
      street # only here
      city # common
    }
  }
  ... on Actor {
    username
    address {
      city # common
      country # only here
    }
  }
}

fragment TypenameWithoutSpreads on User {
  __typename
  firstName
}

fragment TypenameWithoutSpreadsAbstractType on Node {
  __typename
  id
}

fragment TypenameWithCommonSelections on Actor {
  __typename
  name
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

fragment TypenameAlias on Actor {
  _typeAlias: __typename
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

fragment TypenameAliases on Actor {
  _typeAlias1: __typename
  _typeAlias2: __typename
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// TypenameInside.graphql



// TypenameOutside.graphql



// TypenameOutsideWithAbstractType.graphql



// TypenameWithoutSpreads.graphql



// TypenameWithoutSpreadsAbstractType.graphql



// TypenameWithCommonSelections.graphql



// TypenameAlias.graphql



// TypenameAliases.graphql


`;

exports[`Snapshot tests for useHaste matches expected output: unmasked-fragment-spreads.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment UserProfile on User {
  profilePicture(size: $ProfilePicture_SIZE) {
    ...PhotoFragment @relay(mask: false)

    # duplicated field should be merged
    ...AnotherRecursiveFragment @relay(mask: false)

    # Compose child fragment
    ...PhotoFragment
  }
}

fragment PhotoFragment on Image {
  uri
  ...RecursiveFragment @relay(mask: false)
}

fragment RecursiveFragment on Image @relay(mask: false) {
  uri
  width
}

fragment AnotherRecursiveFragment on Image {
  uri
  height
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// UserProfile.graphql



// PhotoFragment.graphql



// RecursiveFragment.graphql



// AnotherRecursiveFragment.graphql


`;

exports[`Snapshot tests for useSingleDirectory matches expected output: refetchable-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment RefetchableFragment on Node
  @refetchable(queryName: "RefetchableFragmentQuery") {
  id
  fragAndField: profilePicture {
    uri
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// RefetchableFragment.graphql



// RefetchableFragmentQuery.graphql
type response = {. "node": Js.Nullable.t(unit)};
type variables = {. "id": string};

`;
