#!/usr/bin/env node
const path = require("path");
const fs = require("fs");
const { parseRE, printRE } = require("reason");
const mkdir = require("mkdirp-sync");
const { spawn } = require("child_process");
const { buildSchema, introspectionQuery, graphql } = require("graphql");

const args = process.argv.slice(2);

function runRelayCompiler(args) {
  spawn(
    path.resolve(
      __dirname + "/../src/vendor/relay-compiler/bin/relay-compiler"
    ),
    args,
    {
      stdio: "inherit"
    }
  );
}

function generateSchemaAssets(schema, targetPath) {
  let enums = schema.data.__schema.types
    .filter(({ kind, name }) => kind === "ENUM" && !name.startsWith("_"))
    .map(e => {
      const { name, enumValues } = e;
      const values = enumValues.map(v => v.name);

      let enumT = `type t = [ ${values
        .map(v => ` | \`${v}`)
        .join("")} | \`FUTURE_ADDED_VALUE__ ]`;

      return `
      module Enum_${name}: {
        ${enumT};
        type wrapped;
        let unwrap: wrapped => t;
        let wrap: t => wrapped;
      } = {
        ${enumT};
        type wrapped;
        
        external __unwrap: wrapped => string = "%identity";
        external __wrap: string => wrapped = "%identity";
        
        let unwrap = wrapped => switch(wrapped |> __unwrap) {
          ${values.map(val => `| "${val}" => \`${val}`).join("")}
          | _ => \`FUTURE_ADDED_VALUE__
        };
        
        let wrap = t => switch(t) {
          ${values.map(val => `| \`${val} => "${val}"`).join("")}
          | \`FUTURE_ADDED_VALUE__ => ""
        } |> __wrap;
      };
      `;
    })
    .join("\n\n");

  fs.writeFileSync(
    path.resolve(targetPath + "/SchemaAssets.re"),
    printRE(
      parseRE(`
/** This file is autogenerated by ReasonRelay and should not be modified manually. */

/**
 * ENUMS
 * Helpers for wrapping/unwrapping enums.
 */

${enums}
     `)
    )
  );
}

async function parseSchema(rawSchemaContent, pathToSchema) {
  const schemaType = pathToSchema.split(".").pop();
  let schema;

  switch (schemaType.toLowerCase()) {
    default:
    case "json":
      schema = JSON.parse(rawSchemaContent);
      break;
    case "graphql":
      const graphqlSchema = buildSchema(rawSchemaContent);
      const jsonIntrospectionSchema = await graphql(
        graphqlSchema,
        introspectionQuery,
        {}
      );
      schema = jsonIntrospectionSchema;
      break;
  }

  return schema;
}

function findArg(name) {
  return args.reduce((acc, curr, index, arr) => {
    if (curr.trim() === "--" + name && arr[index + 1]) {
      acc = arr[index + 1];
    }

    return acc;
  }, null);
}

async function runCompiler() {
  const schemaPath = findArg("schema");

  if (schemaPath) {
    console.log("Generating ReasonRelay assets...");

    const schemaJson = await parseSchema(
      fs.readFileSync(schemaPath, "utf8"),
      schemaPath
    );

    let targetPath = path.resolve("./src/__reasonRelayGenerated__");
    mkdir(targetPath);

    const argsMap = args.reduce((acc, curr, index, arr) => {
      if (curr.startsWith("--")) {
        acc[curr] = arr[index + 1];
      }

      return acc;
    }, {});

    argsMap["--language"] = path.resolve(
      __dirname + "/../language-plugin/index.js"
    );

    runRelayCompiler(
      Object.keys(argsMap).reduce((acc, curr) => {
        acc.push(curr, argsMap[curr]);
        return acc;
      }, [])
    );

    generateSchemaAssets(schemaJson, targetPath);
  } else {
    runRelayCompiler(["--help"]);
  }
}

runCompiler();
